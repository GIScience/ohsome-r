---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# ohsome

<!-- badges: start -->
<!-- badges: end -->

This *ohsome* R package grants access to the power of the *ohsome* API from R.
ohsome is ... OSHDB ... 

## Installation

If you have access to the repository and a 
[personal access token](https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html){target=blank},
you can install the development version of *ohsome* from GitLab:

```{r, eval = FALSE}
Sys.setenv(GITLAB_PAT = your_personal_access_token)

remotes::install_gitlab(
	repo = "giscience/big-data/ohsome/libs/ohsome-r@develop",
	host = "https://gitlab.gistools.geog.uni-heidelberg.de"
)

```

## Getting started

Upon attaching the *ohsome* package, a metadata request is sent to the *ohsome* 
API. The package message provides some essential metadata information, such as
the current temporal extent of the underlying OSHDB:

```{r library}
library(ohsome)
```

The metadata is stored in *.ohsome_metadata*. You can print it to the console
to get more details.

### Aggregate OpenStreetMap elements

This early version of the *ohsome* R package provides wrapper functions for the
elements aggregation endpoints only. With these functions you can query the 
*ohsome* API for the aggregated amount, length, area or perimeter of 
OpenStreetMap elements with given properties, within given boundaries and at 
given points in time.

Here, we create a query for the total amount of breweries on OSM in the German 
region of Franconia. The first argument to *ohsome_elements_count()* is the *sf* 
object *franconia* that is included in the *mapview* package:

```{r elements_count}
library(mapview)

q <- ohsome_elements_count(franconia, filter = "craft=brewery")
```

The resulting *ohsome_query* object can be sent to the *ohsome* API with 
*ohsome_post()*. By default, *ohsome_post()* returns the parsed API response
which is a simple data.frame in this case.

```{r post}
ohsome_post(q)
``` 

We now know that there were 125 breweries in Franconia on OSM at a certain point
in time. However, *ohsome_post()* has issued a warning that the time parameter
of the query was not defined. Thus, the *ohsome* API returned the number of 
elements at the latest available timestamp.

The [time parameter](https://docs.ohsome.org/ohsome-api/stable/time.html){target=blank}
allows to access the OSM history through the *ohsome* API. This would create a 
query of the number of breweries at January 1st of each year between 2010 and 
2020:


```{r time, eval = FALSE}
franconia |> 
	ohsome_elements_count(filter = "craft=brewery", time = "2010/2020/P1Y")
```

Alternatively, we can update the existing *ohsome_query* object *q* with the 
*set_time()* function, pipe the modified query directly into 
*ohsome_post()* and make a quick visualisation with *ggplot2*:

```{r pipe}
library(ggplot2)

q |> 
	set_time("2010/2020/P1Y") |>
	ohsome_post() |>
	ggplot(aes(x = timestamp, y = value)) +
	geom_col()
```

What if we want to know not the total number of breweries in all of Franconia, 
but rather per each district of Franconia? The *set_endpoint()* function can
be used to change or append to the endpoint path of an API request. In this case, 
we would want to append `/groupBy/boundary` to the `elements/count` endpoint. 
The endpoint path can either be given as a single string (`/groupBy/boundary`) or
as a character vector^[The order of the elements in the character vector is 
critical!] as in this example:

```{r groupBy_boundary}
q <- set_time(q, "2021-06-01")

q |>
	set_endpoint(c("groupBy", "boundary"), append = TRUE) |>
	ohsome_post()
```

By default, *ohsome_post()* returns an *sf* object whenever the *ohsome* API 
is capable of delivering GeoJSON data -- which is the case for elements 
extraction queries as well as for aggregations grouped by boundaries.

It is thus possible to easily create a choropleth map from the query results. As
it makes more sense to visualise amounts normalised by area rather than absolute
amounts on such a map, "density" can be added to the endpoint path to query for 
the amount of breweries per square kilometer:

```{r density}
q |>
	set_endpoint(c("density", "groupBy", "boundary"), append = TRUE) |>
	ohsome_post() |>
	mapview(zcol = "value")
```


### Other queries



### Bounding geometries
